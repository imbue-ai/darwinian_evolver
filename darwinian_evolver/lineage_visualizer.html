<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lineage Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            height: calc(100vh - 40px);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }

        .file-input {
            margin-bottom: 10px;
        }

        .file-input input[type="file"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .file-input label {
            display: inline-block;
            margin-right: 10px;
            font-weight: bold;
        }

        .visualization-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex: 1;
            min-height: 0;
        }

        .lineage-tree {
            flex: 2;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
            overflow: auto;
            min-width: 0;
        }

        .timeseries-chart {
            width: 450px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
            padding: 15px;
            overflow: auto;
            flex-shrink: 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .failure-heatmap-section {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
            padding: 15px;
            overflow: auto;
        }

        .heatmap-cell {
            stroke: #333;
            stroke-width: 0.5;
        }

        .heatmap-cell.from-failure-case {
            stroke: #000;
            stroke-width: 1.5;
        }

        .heatmap-label {
            font-size: 10px;
            fill: #333;
            text-anchor: middle;
            dominant-baseline: central;
        }

        .heatmap-axis-label {
            font-size: 12px;
            fill: #333;
            text-anchor: middle;
        }

        .organism-info {
            word-break: normal;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.4;
        }

        .organism-circle {
            cursor: pointer;
            stroke: #333;
            stroke-width: 2;
        }

        .organism-circle:hover {
            stroke-width: 3;
            stroke: #000;
        }

        .organism-circle.selected {
            stroke: #ff4444;
            stroke-width: 4;
        }

        .lineage-link {
            fill: none;
            stroke: #666;
            stroke-width: 2;
            opacity: 0.6;
        }

        .generation-label {
            font-size: 14px;
            font-weight: bold;
            fill: #333;
        }

        .tooltip {
            position: absolute;
            text-align: left;
            width: auto;
            height: auto;
            padding: 8px;
            font: 12px sans-serif;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            max-width: 400px;
            white-space: normal;
            word-wrap: break-word;
        }

        .chart-title {
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            color: #333;
        }

        .legend {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }

        .legend-item {
            display: inline-block;
            margin-left: 20px;
            margin-bottom: 5px;
        }

        .legend-circle {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
            vertical-align: middle;
            border: 1px solid #333;
        }

        .instructions {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #e7f3ff;
            border-left: 4px solid #2196f3;
            border-radius: 4px;
        }

        .instructions h3 {
            margin-top: 0;
            color: #1976d2;
        }

        .instructions ul {
            margin-bottom: 0;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 800px;
            max-height: 80%;
            overflow-y: auto;
            position: relative;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            right: 15px;
            top: 10px;
        }

        .close:hover,
        .close:focus {
            color: #000;
            text-decoration: none;
        }

        .modal-title {
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            padding-right: 40px;
        }

        .json-section {
            margin-bottom: 25px;
        }

        .json-section h4 {
            margin-bottom: 10px;
            color: #555;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }

        /* JSON tree styles */
        .json-tree {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
        }

        .json-key {
            color: #d73a49;
            font-weight: bold;
        }

        .json-string {
            color: #032f62;
        }

        .json-number {
            color: #005cc5;
        }

        .json-boolean {
            color: #e36209;
        }

        .json-null {
            color: #6f42c1;
        }

        .json-array {
            color: #22863a;
        }

        .json-object {
            color: #6f42c1;
        }

        .json-collapse {
            cursor: pointer;
            color: #586069;
            margin-right: 5px;
            user-select: none;
        }

        .json-collapse:hover {
            color: #0366d6;
        }

        .details-link {
            color: #2196f3;
            text-decoration: none;
            font-size: 12px;
            margin-left: 10px;
            cursor: pointer;
        }

        .details-link:hover {
            text-decoration: underline;
        }

        .json-line {
            margin: 2px 0;
            line-height: 1.4;
        }

        .json-colon {
            color: #586069;
        }

        .json-comma {
            color: #586069;
        }

        /* Collapsible section styles */
        .collapsible-section {
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
            overflow: hidden;
            margin-top: 20px;
        }

        .collapsible-header {
            background-color: #f8f9fa;
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ddd;
            user-select: none;
        }

        .collapsible-header:hover {
            background-color: #e9ecef;
        }

        .collapsible-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin: 0;
        }

        .collapsible-toggle {
            font-size: 14px;
            font-weight: bold;
            color: #666;
            transition: transform 0.2s ease;
        }

        .collapsible-toggle.expanded {
            transform: rotate(180deg);
        }

        .collapsible-content {
            padding: 15px;
            display: none;
        }

        .collapsible-content.expanded {
            display: block;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Lineage Visualizer</h1>


        <div class="controls">
            <div class="file-input">
                <label for="jsonl-file">Load JSONL log file:</label>
                <input type="file" id="jsonl-file" accept=".jsonl" />
                <!-- Loading indicator -->
                <div id="loading-indicator" style="display: none; margin-left: 15px; color: #666;">
                    <span id="loading-text">Loading...</span>
                    <span id="loading-progress" style="margin-left: 10px;"></span>
                </div>
            </div>
        </div>

        <div class="visualization-container">
            <div class="lineage-tree">
                <svg id="lineage-svg"></svg>
            </div>
            <div class="timeseries-chart">
                <div class="chart-title">Organism Lineage</div>
                <div id="timeseries-content">
                    <p style="color: #666; text-align: center; margin-top: 50px;">
                        Click on an organism to view its lineage
                    </p>
                </div>
            </div>
        </div>

        <div class="legend" style="display: flex; justify-content: space-between; align-items: center;">
            <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 20px;">
                <div id="property-selector-container" style="display: flex; align-items: center;">
                    <label for="property-selector" style="margin-right: 10px;">Color/Filter Property:</label>
                    <select id="property-selector" style="padding: 5px; border: 1px solid #ddd; border-radius: 4px;">
                        <option value="score">score</option>
                    </select>
                </div>
                <div id="legend-content" style="display: flex; align-items: center; flex-wrap: wrap;">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
            <div class="filter-controls" style="display: flex; align-items: center;">
                <div style="display: flex; align-items: center;">
                    <label for="score-threshold" style="margin-right: 10px;">Minimum <span
                            id="threshold-label">Score</span> To Display:</label>
                    <input type="range" id="score-threshold" min="0" max="1" step="0.01" value="0"
                        style="margin-right: 10px; width: 200px;">
                    <span id="threshold-value">0.00</span>
                </div>
            </div>
        </div>

        <div class="collapsible-section">
            <div class="collapsible-header" onclick="toggleCollapsibleSection('failure-cases')">
                <h3 class="collapsible-title">Failure Cases</h3>
                <span class="collapsible-toggle" id="failure-cases-toggle">▼</span>
            </div>
            <div class="collapsible-content" id="failure-cases-content">
                <div id="heatmap-content">
                    <p style="color: #666; text-align: center; margin-top: 50px;">
                        Click on an organism to view failure cases
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>

    <!-- Modal -->
    <div id="organism-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h3 class="modal-title">Organism Details</h3>
            <div id="modal-content-body">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let organisms = new Map();
        let selectedOrganism = null;
        let scoreThreshold = 0.0;
        let filteredOrganisms = new Set();
        let selectedProperty = 'score'; // Default to score
        let availableProperties = new Set(); // Track available numeric properties

        // Function to get dynamic dimensions
        function getDynamicDimensions() {
            const lineageTreeElement = document.querySelector('.lineage-tree');
            const rect = lineageTreeElement.getBoundingClientRect();
            const margin = { top: 20, right: 20, bottom: 20, left: 60 };
            const width = Math.max(400, rect.width - margin.left - margin.right - 40); // 40px for padding/borders
            const height = Math.max(300, rect.height - margin.top - margin.bottom - 40);
            return { width, height, margin };
        }

        // Color scale for scores (will be updated dynamically)
        let colorScale = d3.scaleSequential(d3.interpolateRdYlGn)
            .domain([0, 1]);

        // Set up SVG (will be resized dynamically)
        const svg = d3.select("#lineage-svg");
        const g = svg.append("g");

        // Tooltip
        const tooltip = d3.select("#tooltip");

        // File input handler with streaming
        document.getElementById('jsonl-file').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file) {
                streamJSONLFile(file);
            }
        });

        // Stream processing function
        async function streamJSONLFile(file) {
            try {
                // Show loading indicator
                showLoadingIndicator();

                // Clear previous data
                organisms.clear();
                availableProperties.clear();

                // Create a readable stream from the file
                const stream = file.stream();
                const reader = stream.pipeThrough(new TextDecoderStream()).getReader();

                let buffer = '';
                let lineCount = 0;

                while (true) {
                    const { done, value } = await reader.read();

                    if (done) {
                        // Process any remaining content in buffer
                        if (buffer.trim()) {
                            await processJSONLine(buffer.trim(), lineCount++);
                        }
                        break;
                    }

                    buffer += value;

                    // Process complete lines
                    if (value.includes('\n')) {
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || ''; // Keep incomplete line in buffer

                        for (const line of lines) {
                            if (line.trim()) {
                                await processJSONLine(line.trim(), lineCount++);

                                // Update progress periodically
                                updateLoadingProgress(lineCount);
                                // Yield control to prevent blocking
                                await new Promise(resolve => setTimeout(resolve, 0));
                            }
                        }
                    }
                }

                // Processing complete
                hideLoadingIndicator();
                calculatePropertyIntersection();
                updatePropertyDropdown();
                updateThresholdRange();
                updateFilteredOrganisms();
                visualizeLineageTree();

            } catch (error) {
                hideLoadingIndicator();
                alert('Error processing file: ' + error.message);
            }
        }

        // Process individual JSON line
        async function processJSONLine(line, lineNumber) {
            try {
                const jsonData = JSON.parse(line);
                processIterationData(jsonData);
            } catch (error) {
                console.warn(`Error parsing line ${lineNumber + 1}: ${error.message}`);
            }
        }


        // Initialize slider on page load to ensure it starts at 0
        window.addEventListener('DOMContentLoaded', function () {
            const slider = document.getElementById('score-threshold');
            const thresholdValue = document.getElementById('threshold-value');

            // Force reset to 0 on page load
            slider.value = 0;
            scoreThreshold = 0.0;
            thresholdValue.textContent = '0.00';
        });

        // Property selector handler
        document.getElementById('property-selector').addEventListener('change', function (e) {
            selectedProperty = e.target.value;
            document.getElementById('threshold-label').textContent = selectedProperty.charAt(0).toUpperCase() + selectedProperty.slice(1);

            // Update threshold slider range based on selected property
            updateThresholdRange();

            // Re-filter and visualize
            updateFilteredOrganisms();
            visualizeLineageTree();
        });

        // Score threshold slider handler
        document.getElementById('score-threshold').addEventListener('input', function (e) {
            scoreThreshold = parseFloat(e.target.value);
            document.getElementById('threshold-value').textContent = scoreThreshold.toFixed(3);
            updateFilteredOrganisms(); // This also calls updateColorScale() and updateLegend()
            // Ensure color scale and legend are updated after filtering
            updateColorScale();
            updateLegend();
            visualizeLineageTree();
        });


        // JSON tree formatting function
        function formatJSONTree(obj, depth = 0) {
            if (obj === null) {
                return `<span class="json-null">null</span>`;
            } else if (typeof obj === 'string') {
                const escaped = obj.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/ /g, '&nbsp;').replace(/\n/g, '<br />');
                return `<span class="json-string">"${escaped}"</span>`;
            } else if (typeof obj === 'number') {
                return `<span class="json-number">${obj}</span>`;
            } else if (typeof obj === 'boolean') {
                return `<span class="json-boolean">${obj}</span>`;
            } else if (Array.isArray(obj)) {
                if (obj.length === 0) {
                    return `<span class="json-array">[]</span>`;
                }

                const id = `array-${Math.random().toString(36).substr(2, 9)}`;
                let result = `<div class="json-line" style="margin-left: ${depth * 20}px;">`;
                result += `<span class="json-collapse" onclick="toggleCollapse('${id}')">▼</span>`;
                result += `<span class="json-array">[</span></div>`;
                result += `<div id="${id}" class="json-collapsible">`;

                obj.forEach((item, index) => {
                    result += `<div class="json-line" style="margin-left: ${(depth + 1) * 20}px;">`;
                    result += formatJSONTree(item, depth + 1);
                    if (index < obj.length - 1) result += '<span class="json-comma">,</span>';
                    result += '</div>';
                });

                result += `</div>`;
                result += `<div class="json-line" style="margin-left: ${depth * 20}px;"><span class="json-array">]</span></div>`;
                return result;
            } else if (typeof obj === 'object') {
                const keys = Object.keys(obj);
                if (keys.length === 0) {
                    return `<span class="json-object">{}</span>`;
                }

                const id = `object-${Math.random().toString(36).substr(2, 9)}`;
                let result = `<div class="json-line" style="margin-left: ${depth * 20}px;">`;
                result += `<span class="json-collapse" onclick="toggleCollapse('${id}')">▼</span>`;
                result += `<span class="json-object">{</span></div>`;
                result += `<div id="${id}" class="json-collapsible">`;

                keys.forEach((key, index) => {
                    result += `<div class="json-line" style="margin-left: ${(depth + 1) * 20}px;">`;
                    result += `<span class="json-key">"${key}"</span><span class="json-colon">:</span> `;
                    result += formatJSONTree(obj[key], depth + 1);
                    if (index < keys.length - 1) result += '<span class="json-comma">,</span>';
                    result += '</div>';
                });

                result += `</div>`;
                result += `<div class="json-line" style="margin-left: ${depth * 20}px;"><span class="json-object">}</span></div>`;
                return result;
            }

            return String(obj);
        }

        function toggleCollapse(id) {
            const element = document.getElementById(id);

            // In the new structure, the toggle button is inside the previous sibling div
            const previousLine = element.previousElementSibling;
            if (!previousLine) return;

            // Find the toggle button within the previous line
            const toggle = previousLine.querySelector('.json-collapse');
            if (!toggle) return;

            if (element.style.display === 'none') {
                element.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                element.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        function normalizeUUID(uuid) {
            if (!uuid) return null;
            // Remove hyphens and reformat as standard UUID
            const clean = uuid.replace(/-/g, '');
            if (clean.length === 32) {
                return clean.substring(0, 8) + '-' +
                    clean.substring(8, 12) + '-' +
                    clean.substring(12, 16) + '-' +
                    clean.substring(16, 20) + '-' +
                    clean.substring(20);
            }
            return uuid; // Return as-is if not the expected format
        }

        function processIterationData(iterData) {
            const iteration = iterData.iteration;

            // Create organism objects for organisms appearing for the first time
            iterData.population.organisms.forEach(orgData => {
                const id = normalizeUUID(orgData.organism.id);
                if (organisms.has(id)) {
                    // Organism has already been processed
                    return;
                }

                const fromChangeSummaryShortened = orgData.organism.from_change_summary &&
                    (orgData.organism.from_change_summary.length > 160 ?
                        orgData.organism.from_change_summary.substring(0, 160) + '...' :
                        orgData.organism.from_change_summary);

                const organism = {
                    id: id,
                    parentId: normalizeUUID(orgData.organism.parent_id),
                    additionalParentIds: orgData.organism.additional_parent_ids ?
                        orgData.organism.additional_parent_ids.map(normalizeUUID).filter(id => id !== null) : [],
                    score: orgData.evaluation_result.score,
                    iteration: iteration,
                    evaluationResult: orgData.evaluation_result,
                    fromChangeSummaryShortened: fromChangeSummaryShortened,
                    source: orgData.organism
                };

                // Calculate lineage depth
                const lineageDepth = calculateLineageDepth(organism);
                organism.lineageGeneration = lineageDepth; //

                organisms.set(organism.id, organism);
            });
        }

        // Function to get numeric properties for a single organism
        function getOrganismProperties(organism) {
            const properties = new Set(['score']); // Always include score

            // Check organism source visualizer_props
            if (organism.source.visualizer_props) {
                for (const [key, value] of Object.entries(organism.source.visualizer_props)) {
                    if (typeof value === 'number') {
                        properties.add(key);
                    }
                }
            }

            // Check evaluation result visualizer_props
            if (organism.evaluationResult && organism.evaluationResult.visualizer_props) {
                for (const [key, value] of Object.entries(organism.evaluationResult.visualizer_props)) {
                    if (typeof value === 'number') {
                        properties.add(key);
                    }
                }
            }

            return properties;
        }

        // Function to calculate intersection of properties across all organisms
        function calculatePropertyIntersection() {
            if (organisms.size === 0) {
                availableProperties.clear();
                return;
            }

            // Start with properties from the first organism
            const organismArray = Array.from(organisms.values());
            let intersection = getOrganismProperties(organismArray[0]);

            // Find intersection with properties from all other organisms
            for (let i = 1; i < organismArray.length; i++) {
                const currentProperties = getOrganismProperties(organismArray[i]);
                intersection = new Set([...intersection].filter(prop => currentProperties.has(prop)));
            }

            availableProperties = intersection;
        }

        // Function to get the value of the selected property for an organism
        function getPropertyValue(organism, property) {
            if (property === 'score') {
                return organism.score;
            }

            // Check evaluation result visualizer_props first
            if (organism.evaluationResult && organism.evaluationResult.visualizer_props &&
                organism.evaluationResult.visualizer_props.hasOwnProperty(property)) {
                return organism.evaluationResult.visualizer_props[property];
            }

            // Check organism source visualizer_props
            if (organism.source.visualizer_props &&
                organism.source.visualizer_props.hasOwnProperty(property)) {
                return organism.source.visualizer_props[property];
            }

            return null; // Property not found
        }

        // Function to update the property dropdown
        function updatePropertyDropdown() {
            const dropdown = document.getElementById('property-selector');
            const currentValue = dropdown.value;

            // Clear and rebuild dropdown
            dropdown.innerHTML = '';

            // Convert to array and sort alphabetically, but put 'score' first
            const sortedProperties = Array.from(availableProperties).sort((a, b) => {
                if (a === 'score') return -1;
                if (b === 'score') return 1;
                return a.localeCompare(b);
            });

            sortedProperties.forEach(property => {
                const option = document.createElement('option');
                option.value = property;
                option.textContent = property;
                dropdown.appendChild(option);
            });

            // Restore selected value if it still exists
            if (availableProperties.has(currentValue)) {
                dropdown.value = currentValue;
                selectedProperty = currentValue;
            } else {
                selectedProperty = 'score';
                dropdown.value = 'score';
            }
        }

        // Function to update threshold range based on selected property
        function updateThresholdRange() {
            if (organisms.size === 0) return;

            const slider = document.getElementById('score-threshold');
            const thresholdValue = document.getElementById('threshold-value');

            // Get all values for the selected property
            const allValues = [];
            organisms.forEach(organism => {
                const propertyValue = getPropertyValue(organism, selectedProperty);
                if (propertyValue !== null) {
                    allValues.push(propertyValue);
                }
            });

            if (allValues.length === 0) {
                slider.min = 0;
                slider.max = 1;
                slider.step = 0.01;
                return;
            }

            const minValue = Math.min(...allValues);
            const maxValue = Math.max(...allValues);

            // Update slider range
            slider.min = minValue;
            slider.max = maxValue;
            slider.step = (maxValue - minValue) / 100;

            // Reset threshold to minimum value
            scoreThreshold = minValue;
            slider.value = minValue;
            thresholdValue.textContent = minValue.toFixed(3);
        }

        function updateFilteredOrganisms() {
            filteredOrganisms.clear();

            // First, add all organisms that meet the selected property threshold
            organisms.forEach(organism => {
                const propertyValue = getPropertyValue(organism, selectedProperty);
                if (propertyValue !== null && propertyValue >= scoreThreshold) {
                    filteredOrganisms.add(organism.id);
                }
            });

            // Then, add all ancestors of the filtered organisms
            const toProcess = new Set(filteredOrganisms);
            toProcess.forEach(organismId => {
                let current = organisms.get(organismId);
                while (current && current.parentId) {
                    if (!filteredOrganisms.has(current.parentId)) {
                        filteredOrganisms.add(current.parentId);
                        toProcess.add(current.parentId);
                    }
                    current = organisms.get(current.parentId);
                }
            });

            // Update color scale based on filtered organisms
            updateColorScale();
            updateLegend();
        }

        // Update color scale based on currently filtered organisms
        function updateColorScale() {
            if (filteredOrganisms.size === 0) {
                colorScale.domain([0, 1]);
                return;
            }

            // Get selected property values from filtered organisms only
            const filteredValues = [];
            filteredOrganisms.forEach(organismId => {
                const organism = organisms.get(organismId);
                if (organism) {
                    const propertyValue = getPropertyValue(organism, selectedProperty);
                    if (propertyValue !== null) {
                        filteredValues.push(propertyValue);
                    }
                }
            });

            if (filteredValues.length === 0) {
                colorScale.domain([0, 1]);
                return;
            }

            const minValue = Math.min(...filteredValues);
            const maxValue = Math.max(...filteredValues);

            // Handle edge case where all values are the same
            if (minValue === maxValue) {
                colorScale.domain([minValue - 0.1, maxValue + 0.1]);
            } else {
                colorScale.domain([minValue, maxValue]);
            }
        }

        // Update legend with current property range
        function updateLegend() {
            if (filteredOrganisms.size === 0) return;

            // Get current domain
            const domain = colorScale.domain();
            const minValue = domain[0];
            const maxValue = domain[1];
            const midValue = (minValue + maxValue) / 2;

            // Update legend items - target the specific legend content container
            const legendContent = document.getElementById('legend-content');

            // Capitalize property name for display
            const displayName = selectedProperty.charAt(0).toUpperCase() + selectedProperty.slice(1);

            legendContent.innerHTML = `
                <strong>${displayName} Color Scale:</strong>
                <div class="legend-item">
                    <span class="legend-circle" style="background-color: ${colorScale(minValue)};"></span>
                    <span>Low ${displayName} (${minValue.toFixed(3)})</span>
                </div>
                <div class="legend-item">
                    <span class="legend-circle" style="background-color: ${colorScale(midValue)};"></span>
                    <span>Medium ${displayName} (${midValue.toFixed(3)})</span>
                </div>
                <div class="legend-item">
                    <span class="legend-circle" style="background-color: ${colorScale(maxValue)};"></span>
                    <span>High ${displayName} (${maxValue.toFixed(3)})</span>
                </div>
            `;
        }

        // Calculate lineage depth (generation) for an organism
        function calculateLineageDepth(organism) {
            let depth = 0;
            let current = organism;

            while (current) {
                if (!current.parentId) {
                    // Reached root organism
                    break;
                }
                current = organisms.get(current.parentId);
                depth++;
            }

            return depth;
        }

        function visualizeLineageTree() {
            // Clear previous visualization
            g.selectAll("*").remove();

            if (organisms.size === 0) return;

            // Update color scale and legend based on current filtered organisms
            updateColorScale();
            updateLegend();

            // Get current dimensions
            const dimensions = getDynamicDimensions();
            const { width, height, margin } = dimensions;

            // Update SVG size
            svg.attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);

            g.attr("transform", `translate(${margin.left},${margin.top})`);

            // Group by lineage generation, only include filtered organisms
            const lineageGenerations = new Map();

            organisms.forEach(organism => {
                // Skip organisms that are not in the filtered set
                if (!filteredOrganisms.has(organism.id)) return;

                const lineageDepth = organism.lineageGeneration;

                if (!lineageGenerations.has(lineageDepth)) {
                    lineageGenerations.set(lineageDepth, []);
                }
                lineageGenerations.get(lineageDepth).push(organism);
            });

            // Convert to array and sort by lineage generation
            const lineageGenerationData = Array.from(lineageGenerations.entries())
                .map(([generation, organisms]) => ({ generation, organisms }))
                .sort((a, b) => a.generation - b.generation);

            // For generations >= 1, sort organisms by the order of their parents in the previous generation
            lineageGenerationData.forEach(genData => {
                if (genData.generation >= 1) {
                    // Create a map of parent positions in the previous generation
                    const prevGenData = lineageGenerationData.find(g => g.generation === genData.generation - 1);
                    if (prevGenData) {
                        const parentPositions = new Map();
                        prevGenData.organisms.forEach((parent, index) => {
                            parentPositions.set(parent.id, index);
                        });

                        // Sort organisms by their parent's position in the previous generation
                        genData.organisms.sort((a, b) => {
                            const parentPosA = parentPositions.get(a.parentId) ?? -1;
                            const parentPosB = parentPositions.get(b.parentId) ?? -1;

                            // If parents are different, sort by parent position
                            if (parentPosA !== parentPosB) {
                                return parentPosA - parentPosB;
                            }

                            // If same parent or both have no parent, maintain original order
                            return 0;
                        });
                    }
                }
            });

            // Calculate layout based on lineage generations
            const maxLineageGeneration = Math.max(...lineageGenerationData.map(g => g.generation));
            const maxOrganismsPerGen = Math.max(...lineageGenerationData.map(g => g.organisms.length));

            const generationHeight = height / (maxLineageGeneration + 1);
            const organismRadius = Math.min(15, width / (maxOrganismsPerGen * 3));

            // Position organisms based on lineage generation
            lineageGenerationData.forEach(genData => {
                const y = genData.generation * generationHeight;
                const organismWidth = width / (genData.organisms.length + 1);

                genData.organisms.forEach((organism, i) => {
                    organism.x = (i + 1) * organismWidth;
                    organism.y = y;
                });
            });

            // Draw connections (parent-child lines)
            // Only show links between filtered organisms
            const links = [];
            const additionalLinks = [];
            organisms.forEach(organism => {
                if (!filteredOrganisms.has(organism.id)) return;

                // Primary parent connection
                if (organism.parentId) {
                    const parent = organisms.get(organism.parentId);
                    if (parent && filteredOrganisms.has(parent.id)) {
                        links.push({
                            source: parent,
                            target: organism
                        });
                    }
                }

                // Additional parent connections
                if (organism.additionalParentIds && organism.additionalParentIds.length > 0) {
                    organism.additionalParentIds.forEach(additionalParentId => {
                        const additionalParent = organisms.get(additionalParentId);
                        if (additionalParent && filteredOrganisms.has(additionalParent.id)) {
                            additionalLinks.push({
                                source: additionalParent,
                                target: organism
                            });
                        }
                    });
                }
            });

            // Draw primary parent links (solid lines)
            g.selectAll(".lineage-link")
                .data(links)
                .enter()
                .append("line")
                .attr("class", "lineage-link")
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            // Draw additional parent links (light dotted lines)
            g.selectAll(".additional-lineage-link")
                .data(additionalLinks)
                .enter()
                .append("line")
                .attr("class", "additional-lineage-link")
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y)
                .attr("stroke", "#999")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "2,3")
                .attr("opacity", 0.5)
                .attr("fill", "none");

            // Draw generation labels
            g.selectAll(".generation-label")
                .data(lineageGenerationData)
                .enter()
                .append("text")
                .attr("class", "generation-label")
                .attr("x", -10)
                .attr("y", d => d.generation * generationHeight + 5)
                .text(d => `Gen ${d.generation}`);

            // Draw organisms
            // Only render filtered organisms
            const filteredOrganismsList = Array.from(organisms.values()).filter(organism =>
                filteredOrganisms.has(organism.id)
            );

            const organismNodes = g.selectAll(".organism-circle")
                .data(filteredOrganismsList)
                .enter()
                .append("circle")
                .attr("class", "organism-circle")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", organismRadius)
                .attr("fill", d => {
                    const propertyValue = getPropertyValue(d, selectedProperty);
                    return propertyValue !== null ? colorScale(propertyValue) : '#ccc';
                })
                .on("click", handleOrganismClick)
                .on("mouseover", showTooltip)
                .on("mouseout", hideTooltip);

            // Update SVG height based on content if needed
            const contentHeight = (maxLineageGeneration + 1) * generationHeight + margin.top + margin.bottom;
            const currentHeight = height + margin.top + margin.bottom;
            if (contentHeight > currentHeight) {
                svg.attr("height", contentHeight);
            }
        }

        function formatVisualizerProperties(organism, options = {}) {
            const { useStrongTags = true, includeLineBreaks = true } = options;
            let propertiesHtml = '';

            // Add organism-specific visualizer properties
            if (organism.source.visualizer_props) {
                for (const [key, value] of Object.entries(organism.source.visualizer_props)) {
                    const formattedValue = typeof value === 'number' ? value.toFixed(3) : value;
                    if (useStrongTags) {
                        propertiesHtml += `<strong>${key}:</strong> ${formattedValue}`;
                    } else {
                        propertiesHtml += `${key}: ${formattedValue}`;
                    }
                    if (includeLineBreaks) {
                        propertiesHtml += '<br/>';
                    }
                }
            }

            // Add evaluation result visualizer properties
            if (organism.evaluationResult && organism.evaluationResult.visualizer_props) {
                for (const [key, value] of Object.entries(organism.evaluationResult.visualizer_props)) {
                    const formattedValue = typeof value === 'number' ? value.toFixed(3) : value;
                    if (useStrongTags) {
                        propertiesHtml += `<strong>${key}:</strong> ${formattedValue}`;
                    } else {
                        propertiesHtml += `${key}: ${formattedValue}`;
                    }
                    if (includeLineBreaks) {
                        propertiesHtml += '<br/>';
                    }
                }
            }

            return propertiesHtml;
        }

        function handleOrganismClick(event, organism) {
            // Update selection visual
            g.selectAll(".organism-circle").classed("selected", false);
            d3.select(event.target).classed("selected", true);

            selectedOrganism = organism;
            showLineageTimeseries(organism);
            showFailureCasesHeatmap(organism);
        }

        function showTooltip(event, organism) {
            let tooltipHtml = `
                <strong>ID:</strong> ${organism.id.substring(0, 8)}...<br/>
                <strong>Parent:</strong> ${organism.parentId ? organism.parentId.substring(0, 8) + '...' : 'None'}<br/>
            `;

            // Add additional parents if they exist
            if (organism.additionalParentIds && organism.additionalParentIds.length > 0) {
                tooltipHtml += `<strong>Additional Parents:</strong> ${organism.additionalParentIds.map(id => id.substring(0, 8) + '...').join(', ')}<br/>`;
            }

            tooltipHtml += `
                <strong>Iteration:</strong> ${organism.iteration}<br/>
                <strong>Score:</strong> ${organism.score.toFixed(3)}<br/>
                <strong>Change Summary:</strong> ${organism.fromChangeSummaryShortened ? organism.fromChangeSummaryShortened : 'N/A'}<br/>
            `;

            // Add visualizer properties using helper function
            tooltipHtml += formatVisualizerProperties(organism);

            tooltip.style("opacity", 1)
                .html(tooltipHtml)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
        }

        function hideTooltip() {
            tooltip.style("opacity", 0);
        }

        function showLineageTimeseries(organism) {
            // Trace lineage back to root
            const lineage = [];
            let current = organism;

            while (current) {
                lineage.unshift(current);
                current = current.parentId ? organisms.get(current.parentId) : null;
            }

            // Get best values per lineage generation for comparison (using selected property)
            const bestValuesByLineageGeneration = new Map();
            organisms.forEach(org => {
                const lineageGen = org.lineageGeneration;
                const propertyValue = getPropertyValue(org, selectedProperty);
                if (propertyValue !== null) {
                    const currentBest = bestValuesByLineageGeneration.get(lineageGen);
                    if (!currentBest || propertyValue > currentBest) {
                        bestValuesByLineageGeneration.set(lineageGen, propertyValue);
                    }
                }
            });

            const bestValues = Array.from(bestValuesByLineageGeneration.entries())
                .map(([lineageGeneration, value]) => ({ lineageGeneration, value }))
                .sort((a, b) => a.lineageGeneration - b.lineageGeneration);

            // Create timeseries chart with complete cleanup
            const container = document.getElementById('timeseries-content');
            container.innerHTML = '';

            // Create a unique chart container to ensure complete isolation
            const chartId = `chart-${Date.now()}`;
            container.innerHTML = `<div id="${chartId}"></div>`;
            const cleanContainer = d3.select(`#${chartId}`);

            // Add chart title with organism info
            let organismInfoHtml = `
                <strong>Selected Organism:</strong><br/>
                ID: ${organism.id.substring(0, 8)}...<br/>
                Parent: ${organism.parentId ? organism.parentId.substring(0, 8) + '...' : 'None'}<br/>
            `;

            // Add additional parents if they exist
            if (organism.additionalParentIds && organism.additionalParentIds.length > 0) {
                organismInfoHtml += `Additional Parents: ${organism.additionalParentIds.map(id => id.substring(0, 8) + '...').join(', ')}<br/>`;
            }

            organismInfoHtml += `
                Generation: ${organism.lineageGeneration}<br/>
                Iteration: ${organism.iteration}<br/>
                Score: ${organism.score.toFixed(3)}<br/>
                Change Summary: ${organism.fromChangeSummaryShortened ? organism.fromChangeSummaryShortened : 'N/A'}<br/>
            `;

            // Add visualizer properties using helper function
            organismInfoHtml += formatVisualizerProperties(organism, { useStrongTags: false });

            organismInfoHtml += `<a href="#" class="details-link" onclick="showOrganismDetails('${organism.id}'); return false;">See details</a>`;

            cleanContainer.append("div")
                .attr("class", "organism-info")
                .style("margin-bottom", "15px")
                .style("padding", "10px")
                .style("background-color", "#f8f9fa")
                .style("border-radius", "5px")
                .html(organismInfoHtml);

            const chartWidth = 350;
            const chartHeight = 200;
            const chartMargin = { top: 20, right: 20, bottom: 40, left: 50 };

            const chartSvg = cleanContainer.append("svg")
                .attr("width", chartWidth)
                .attr("height", chartHeight);

            const chartG = chartSvg.append("g")
                .attr("transform", `translate(${chartMargin.left},${chartMargin.top})`);


            const chartInnerWidth = chartWidth - chartMargin.left - chartMargin.right;
            const chartInnerHeight = chartHeight - chartMargin.top - chartMargin.bottom;

            // Scales - include both lineage and best values ranges
            const lineageGenerations = lineage.map(d => d.lineageGeneration);
            const bestValueGenerations = bestValues.map(d => d.lineageGeneration);
            const allGenerations = [...lineageGenerations, ...bestValueGenerations];
            const maxGeneration = allGenerations.length > 0 ? Math.max(...allGenerations) : 0;

            const xScale = d3.scaleLinear()
                .domain([0, maxGeneration])
                .range([0, chartInnerWidth]);

            // Get all property values for Y scale domain
            const allPropertyValues = [];
            lineage.forEach(org => {
                const value = getPropertyValue(org, selectedProperty);
                if (value !== null) allPropertyValues.push(value);
            });
            bestValues.forEach(d => allPropertyValues.push(d.value));

            const yMin = allPropertyValues.length > 0 ? Math.min(...allPropertyValues) : 0;
            const yMax = allPropertyValues.length > 0 ? Math.max(...allPropertyValues) : 1;
            const yPadding = (yMax - yMin) * 0.1;

            const yScale = d3.scaleLinear()
                .domain([Math.max(0, yMin - yPadding), yMax + yPadding])
                .range([chartInnerHeight, 0]);

            // Axes - create unique integer tick values
            const tickValues = [];
            for (let i = 0; i <= maxGeneration; i++) {
                tickValues.push(i);
            }

            chartG.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0,${chartInnerHeight})`)
                .call(d3.axisBottom(xScale)
                    .tickValues(tickValues)
                    .tickFormat(d3.format("d")))
                .selectAll("path, line")
                .style("stroke", "#ddd")
                .style("stroke-width", 1);

            chartG.append("g")
                .attr("class", "y-axis")
                .call(d3.axisLeft(yScale))
                .selectAll("path, line")
                .style("stroke", "#ddd")
                .style("stroke-width", 1);

            // Axis labels
            const displayProperty = selectedProperty.charAt(0).toUpperCase() + selectedProperty.slice(1);
            chartG.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - chartMargin.left)
                .attr("x", 0 - (chartInnerHeight / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-size", "12px")
                .text(displayProperty);

            chartG.append("text")
                .attr("transform", `translate(${chartInnerWidth / 2}, ${chartInnerHeight + chartMargin.bottom - 5})`)
                .style("text-anchor", "middle")
                .style("font-size", "12px")
                .text("Generation");

            // Line generators
            const line = d3.line()
                .x(d => xScale(d.lineageGeneration))
                .y(d => {
                    const value = d.value !== undefined ? d.value : getPropertyValue(d, selectedProperty);
                    return yScale(value);
                })
                .defined(d => {
                    const value = d.value !== undefined ? d.value : getPropertyValue(d, selectedProperty);
                    return d.lineageGeneration !== undefined && value !== null;
                });

            // Draw best values line (dashed grey line)
            if (bestValues.length > 0) {
                chartG.append("path")
                    .datum(bestValues)
                    .attr("class", "best-values-line")
                    .attr("fill", "none")
                    .attr("stroke", "#999")
                    .attr("stroke-width", 2)
                    .attr("stroke-dasharray", "5,5")
                    .attr("d", line);
            }

            // Draw selected organism's lineage
            chartG.append("path")
                .datum(lineage)
                .attr("class", "lineage-line")
                .attr("fill", "none")
                .attr("stroke", "#2196f3")
                .attr("stroke-width", 3)
                .attr("d", line);

            // Add points for best values
            if (bestValues.length > 0) {
                chartG.selectAll(".best-value-point")
                    .data(bestValues)
                    .enter()
                    .append("circle")
                    .attr("class", "best-value-point")
                    .attr("cx", d => xScale(d.lineageGeneration))
                    .attr("cy", d => yScale(d.value))
                    .attr("r", 3)
                    .attr("fill", "#999")
                    .attr("stroke", "white")
                    .attr("stroke-width", 1);
            }

            // Add points for lineage
            chartG.selectAll(".lineage-point")
                .data(lineage)
                .enter()
                .append("circle")
                .attr("class", "lineage-point")
                .attr("cx", d => xScale(d.lineageGeneration))
                .attr("cy", d => {
                    const value = getPropertyValue(d, selectedProperty);
                    return yScale(value);
                })
                .attr("r", 4)
                .attr("fill", "#2196f3")
                .attr("stroke", "white")
                .attr("stroke-width", 2);

            // Add legend
            const legend = cleanContainer.append("div")
                .style("margin-top", "10px")
                .style("font-size", "12px");

            legend.append("div")
                .html('<span style="color: #2196f3; font-weight: bold;">━━━</span> Selected Organism Lineage');

            legend.append("div")
                .html(`<span style="color: #999; font-weight: bold;">┅┅┅</span> Best ${displayProperty} per Generation`);
        }

        function showFailureCasesHeatmap(organism) {
            // Trace lineage back to root
            const lineage = [];
            let current = organism;

            while (current) {
                lineage.unshift(current);
                current = current.parentId ? organisms.get(current.parentId) : null;
            }

            // Extract all unique data_point_ids from failure cases in the lineage
            const allDataPointIds = new Set();
            lineage.forEach(org => {
                if (org.evaluationResult) {
                    // Combine trainable and holdout failure cases
                    const allFailureCases = [
                        ...(org.evaluationResult.trainable_failure_cases || []),
                        ...(org.evaluationResult.holdout_failure_cases || [])
                    ];
                    allFailureCases.forEach(fc => {
                        allDataPointIds.add(fc.data_point_id);
                    });
                }
            });

            const sortedDataPointIds = Array.from(allDataPointIds).sort();

            if (sortedDataPointIds.length === 0) {
                // No failure cases to display
                const container = document.getElementById('heatmap-content');
                container.innerHTML = '<p style="color: #666; text-align: center; margin-top: 50px;">No failure cases in lineage</p>';
                return;
            }

            // Check if the failure cases section is collapsed, and if so, temporarily expand it for rendering
            const failureCasesContent = document.getElementById('failure-cases-content');
            const wasCollapsed = !failureCasesContent.classList.contains('expanded');

            if (wasCollapsed) {
                // Temporarily make visible for dimension calculations
                failureCasesContent.style.display = 'block';
                failureCasesContent.style.visibility = 'hidden';
            }

            // Create heatmap data matrix
            const heatmapData = [];
            lineage.forEach((org, orgIndex) => {
                const failureDataPointIds = new Set();
                const fromFailureDataPointIds = new Set();

                // Get failure cases from evaluation result
                if (org.evaluationResult) {
                    // Combine trainable and holdout failure cases
                    const allFailureCases = [
                        ...(org.evaluationResult.trainable_failure_cases || []),
                        ...(org.evaluationResult.holdout_failure_cases || [])
                    ];
                    allFailureCases.forEach(fc => {
                        failureDataPointIds.add(fc.data_point_id);
                    });
                }

                // Get from_failure_cases if they exist
                if (org.source && org.source.from_failure_cases) {
                    org.source.from_failure_cases.forEach(fc => {
                        fromFailureDataPointIds.add(fc.data_point_id);
                    });
                }

                sortedDataPointIds.forEach((dataPointId, dataPointIndex) => {
                    const isFailing = failureDataPointIds.has(dataPointId);
                    const isFromFailure = fromFailureDataPointIds.has(dataPointId);

                    heatmapData.push({
                        organism: org,
                        organismIndex: orgIndex,
                        dataPointId: dataPointId,
                        dataPointIndex: dataPointIndex,
                        isFailing: isFailing,
                        isFromFailure: isFromFailure
                    });
                });
            });

            // Clear previous heatmap
            const container = document.getElementById('heatmap-content');
            container.innerHTML = '';

            // Create heatmap dimensions using full width (x=datapoints, y=organisms)
            const containerWidth = container.clientWidth - 30; // Account for padding
            const maxHeatmapHeight = 300;
            const cellSize = Math.min(
                Math.floor(containerWidth / sortedDataPointIds.length),
                Math.floor(maxHeatmapHeight / lineage.length),
                20
            );
            const heatmapWidth = sortedDataPointIds.length * cellSize;
            const heatmapHeight = lineage.length * cellSize;

            const heatmapMargin = { top: 20, right: 20, bottom: 20, left: 60 };

            // Create SVG
            const heatmapSvg = d3.select(container)
                .append("svg")
                .attr("width", heatmapWidth + heatmapMargin.left + heatmapMargin.right)
                .attr("height", heatmapHeight + heatmapMargin.top + heatmapMargin.bottom);

            const heatmapG = heatmapSvg.append("g")
                .attr("transform", `translate(${heatmapMargin.left},${heatmapMargin.top})`);

            // Draw cells (x=datapoints, y=organisms)
            heatmapG.selectAll(".heatmap-cell")
                .data(heatmapData)
                .enter()
                .append("rect")
                .attr("class", d => `heatmap-cell ${d.isFromFailure ? 'from-failure-case' : ''}`)
                .attr("x", d => d.dataPointIndex * cellSize)
                .attr("y", d => d.organismIndex * cellSize)
                .attr("width", cellSize - 1)
                .attr("height", cellSize - 1)
                .attr("fill", d => {
                    if (d.isFailing) {
                        return d.isFromFailure ? "#cc0000" : "#ff6666"; // Dark red for from_failure_cases, light red for regular failures
                    } else {
                        return d.isFromFailure ? "#006600" : "#66cc66"; // Dark green for from_failure_cases, light green for non-failures
                    }
                })
                .on("mouseover", function (event, d) {
                    // Show tooltip with details
                    const tooltipHtml = `
                        <strong>Organism:</strong> ${d.organism.id} (Gen ${d.organism.lineageGeneration})<br/>
                        <strong>Data Point:</strong> ${d.dataPointId}<br/>
                        <strong>Status:</strong> ${d.isFailing ? 'Failure' : 'Success'}<br/>
                        <strong>Was Mutator Input:</strong> ${d.isFromFailure ? 'Yes' : 'No'}<br/>
                    `;
                    tooltip.style("opacity", 1)
                        .html(tooltipHtml)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function () {
                    tooltip.style("opacity", 0);
                });


            // Add axis titles
            heatmapSvg.append("text")
                .attr("class", "heatmap-axis-label")
                .attr("x", heatmapMargin.left + heatmapWidth / 2)
                .attr("y", heatmapHeight + heatmapMargin.top + heatmapMargin.bottom - 5)
                .text("Data Point");

            heatmapSvg.append("text")
                .attr("class", "heatmap-axis-label")
                .attr("transform", `rotate(90, 30, ${heatmapMargin.top + heatmapHeight / 2})`)
                .attr("x", 30)
                .attr("y", heatmapMargin.top + heatmapHeight / 2)
                .text("Generation (Root → Selected)");

            // Add legend
            const legendContainer = d3.select(container)
                .append("div")
                .style("margin-top", "15px")
                .style("display", "flex")
                .style("flex-wrap", "wrap")
                .style("gap", "15px")
                .style("font-size", "12px");

            // Legend items
            const legendItems = [
                { color: "#66cc66", label: "Success" },
                { color: "#006600", label: "Success (mutator input)" },
                { color: "#ff6666", label: "Failure" },
                { color: "#cc0000", label: "Failure (mutator input)" }
            ];

            legendItems.forEach(item => {
                const legendItem = legendContainer.append("div")
                    .style("display", "flex")
                    .style("align-items", "center");

                legendItem.append("div")
                    .style("width", "12px")
                    .style("height", "12px")
                    .style("background-color", item.color)
                    .style("border", "1px solid #333")
                    .style("margin-right", "5px");

                legendItem.append("span")
                    .text(item.label);
            });

            // Restore collapsed state if it was originally collapsed
            if (wasCollapsed) {
                failureCasesContent.style.display = '';
                failureCasesContent.style.visibility = '';
            }
        }

        // Modal functionality
        function showOrganismDetails(organismId) {
            const organism = organisms.get(organismId);
            if (!organism) return;

            const modal = document.getElementById('organism-modal');
            const modalBody = document.getElementById('modal-content-body');

            modalBody.innerHTML = `
                <div class="json-section">
                    <h4>Organism</h4>
                    <div class="json-tree">${formatJSONTree(organism.source)}</div>
                </div>
                <div class="json-section">
                    <h4>Evaluation Result</h4>
                    <div class="json-tree">${formatJSONTree(organism.evaluationResult)}</div>
                </div>
            `;

            modal.style.display = 'block';
        }

        // Modal close functionality
        const modal = document.getElementById('organism-modal');
        const closeBtn = modal.querySelector('.close');

        closeBtn.onclick = function () {
            modal.style.display = 'none';
        };

        window.onclick = function (event) {
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        };

        // Window resize handler
        let resizeTimeout;
        window.addEventListener('resize', function () {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function () {
                if (organisms.size > 0) {
                    visualizeLineageTree();
                }
            }, 100);
        });

        // Loading indicator functions
        function showLoadingIndicator() {
            const indicator = document.getElementById('loading-indicator');
            const text = document.getElementById('loading-text');
            const progress = document.getElementById('loading-progress');

            indicator.style.display = 'inline-block';
            text.textContent = 'Loading file...';
            progress.textContent = '';
        }

        function updateLoadingProgress(lineCount) {
            const progress = document.getElementById('loading-progress');
            progress.textContent = `(${lineCount} lines processed)`;
        }

        function hideLoadingIndicator() {
            const indicator = document.getElementById('loading-indicator');
            indicator.style.display = 'none';
        }

        // Collapsible section functionality
        function toggleCollapsibleSection(sectionId) {
            const content = document.getElementById(sectionId + '-content');
            const toggle = document.getElementById(sectionId + '-toggle');

            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                toggle.classList.remove('expanded');
            } else {
                content.classList.add('expanded');
                toggle.classList.add('expanded');
            }
        }
    </script>
</body>

</html>
